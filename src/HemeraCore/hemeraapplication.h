#ifndef HEMERA_HEMERAAPPLICATION_H
#define HEMERA_HEMERAAPPLICATION_H

#include <HemeraCore/AsyncInitDBusObject>
#include <HemeraCore/Global>

#include <QtCore/QCoreApplication>

/**
 * @defgroup HemeraCore Hemera Core
 *
 * Hemera Core is the backbone for every Hemera Application, and includes every basic component needed
 * for applications to run. It is meant to be as minimal as possible, and does not depend on any UI feature.
 *
 * It is contained in the Hemera:: namespace.
 */

/**
 * @addtogroup GlobalMacros
 *
 * @{
 */

/**
 * @brief Declares an Application based on QtWidgets
 *
 * Place this macro at the end of the main cpp file of your application if your
 * application is going to use QtWidgets. In such a case, a QApplication will be
 * spawned when invoking this macro and the QtWidgets module will be ready for use.
 *
 * @sa HEMERA_GUI_APPLICATION_MAIN
 */
#define HEMERA_WIDGETS_APPLICATION_MAIN(Class) \
    int main(int argc, char *argv[]) \
    { \
        QApplication app(argc, argv); \
        Class happ; \
        return happ.exec(); \
    }
/**
 * @brief Declares an Application based on QtGui
 *
 * Place this macro at the end of the main cpp file of your application if your
 * application is going to use QtGui. In such a case, a QGuiApplication will be
 * spawned when invoking this macro.
 *
 * @sa HEMERA_WIDGETS_APPLICATION_MAIN
 * @sa HEMERA_HEADLESS_APPLICATION_MAIN
 */
#define HEMERA_GUI_APPLICATION_MAIN(Class) \
    int main(int argc, char *argv[]) \
    { \
        QGuiApplication app(argc, argv); \
        Class happ; \
        return happ.exec(); \
    }
/**
 * @brief Declares an Application based on QtCore
 *
 * Place this macro at the end of the main cpp file of your application if your
 * application is not going to use any GUI feature. Usually, this is the right
 * choice for daemons. A QCoreApplication will be spawned when invoking this macro.
 *
 * @sa HEMERA_WIDGETS_APPLICATION_MAIN
 * @sa HEMERA_HEADLESS_APPLICATION_MAIN
 */
#define HEMERA_HEADLESS_APPLICATION_MAIN(Class) \
    int main(int argc, char *argv[]) \
    { \
        QCoreApplication app(argc, argv); \
        Class happ; \
        return happ.exec(); \
    }

/** @} */

class QIODevice;

namespace Hemera {

class ApplicationProperties;
class Gravity;
class Operation;

class ApplicationPrivate;
/**
 * @class Application
 * @ingroup HemeraCore
 * @headerfile Hemera/hemeraapplication.h <HemeraCore/Application>
 *
 * @brief The base class for Hemera applications and daemons
 *
 * Application is the base class for any Hemera application. It cannot be subclassed
 * directly: @ref GuiApplication, @ref WidgetsApplication, @ref HeadlessApplication or one of their
 * subclasses should be subclassed instead, depending on the type of your application.
 *
 * Application is a state machine based on @ref AsyncInitObject, hence it has an initialization
 * cycle which can be controlled by the developer. Once initialized, it is automatically exposed
 * over its Orbit's bus, identified by its ID.
 *
 * The communication over the Orbit bus is always kept fully transparent, and is a mere detail to the developer:
 * the SDK takes care of all the needed IPC logic under the hood for communicating with Hemera components.
 *
 * @par .ha files and Application properties
 * .ha files are descriptors for the Application (more on ha files: @ref Qt5ApplicationHowTo). The most important information they
 * carry at runtime is the Application's id.
 *
 * @par
 * The ID is in a [reverse domain name notation](http://en.wikipedia.org/wiki/Reverse_domain_name_notation),
 * or more specifically a well-known DBus service name. The application will be uniquely identified over the
 * whole system with its id.
 *
 * @par
 * As .ha files are in QML and need a JavaScript engine to be brought up, ha are never parsed at runtime for
 * performance reasons. Instead, a @ref ApplicationProperties subclass is generated at compile-time, parsing
 * the .ha file and injecting all the needed runtime information straight into the Application's binary.
 * Whenever an application is constructed, it requires to be given an @ref ApplicationProperties instance.
 * Such a class is automatically generated by @ref hemera_add_application_properties CMake Macro, or by your
 * ha buildsystem without the need for you to do anything.
 *
 * @par Creating an Application
 * Hemera Applications do not need a main method - instead, they rely on a set of macros which automatically
 * generate the needed startup logic. As such, your cpp file will look something like this:
 *
 * @par
 * @code
 * MyApplication::MyApplication()
 *     : Hemera::HeadlessApplication(new MyApplicationProperties)
 * {
 * [...]
 *
 * HEMERA_HEADLESS_APPLICATION_MAIN(MyApplication)
 * @endcode
 *
 * @par
 * The @p HEMERA_HEADLESS_APPLICATION_MAIN macro takes care of creating a main method, starting the main loop and
 * triggering the initialization logic of the application. Other macros are available for starting application
 * with a GUI.
 *
 * @par An Application's lifecycle
 * As an application initializes, it immediately connects to the Orbit bus, allowing for easy IPC, but most of
 * all for access Hemera Orbit Control. In fact, Gravity handles the Application's execution state entirely, whereas
 * the application should not interfere with it.
 *
 * @par
 * For this reason, access to @ref start, @ref stop and @ref quit is unallowed to any call which
 * isn't coming from the bus. The auto generated policy for the DBus and application-level checks
 * carries the warranty that only Gravity will be capable of calling into those methods.
 * Of course, the application developer shouldn't interact with QCoreApplication to avoid any possible
 * interference.
 *
 */
class HEMERA_QT5_SDK_EXPORT Application : public Hemera::AsyncInitDBusObject
{
    Q_OBJECT
    Q_DISABLE_COPY(Application)
    Q_DECLARE_PRIVATE_D(d_h_ptr, Application)
    Q_CLASSINFO("D-Bus Interface", "com.ispirata.Hemera.Application")

    Q_PROPERTY(QString id READ id)
    Q_PROPERTY(uint applicationStatus READ applicationStatus NOTIFY applicationStatusChanged)
    Q_PROPERTY(bool satellite READ isSatellite)

    Q_PRIVATE_SLOT(d_func(), void quitImpl())

public:
    /**
     * @brief Describes the status of the @ref Application.
     *
     * An @ref Application is a state machine which can be either stopped or started depending
     * on its status. Usually, this is done by Gravity.
     *
     * It is possible to monitor the current application state through either @ref applicationStatus
     * or the @ref applicationStatusChanged signal.
     */
    enum ApplicationStatus : quint8 {
        /// The @ref Application has just been created and is waiting for initialization.
        NotInitialized = HEMERA_ENUM_Application_ApplicationStatus_NotInitialized,
        /// The @ref Application is being initialized.
        Initializing = HEMERA_ENUM_Application_ApplicationStatus_Initializing,
        /** The @ref Application is stopped and initialized. From this status, the @ref Application can be
         *  safely started. When stopped, an application should not react neither to internal nor external
         *  events - it has to be seen as completely idle by the system.
         */
        Stopped = HEMERA_ENUM_Application_ApplicationStatus_Stopped,
        /// The @ref Application is being started.
        Starting = HEMERA_ENUM_Application_ApplicationStatus_Starting,
        /// The @ref Application is running.
        Running = HEMERA_ENUM_Application_ApplicationStatus_Running,
        /// The @ref Application is being stopped.
        Stopping = HEMERA_ENUM_Application_ApplicationStatus_Stopping,
        /// The @ref Application went through a critical failure, and it will be shutdown right after.
        Failed = HEMERA_ENUM_Application_ApplicationStatus_Failed,
        /**
         * The @ref Application is shutting down. This situation cannot be aborted, and the application
         * is currently living on just to clean up its resources, if needed.
         *
         * @see prepareForShutdown
         */
        ShuttingDown = HEMERA_ENUM_Application_ApplicationStatus_ShuttingDown,
        /**
         * The @ref Application is ready to be shut down. When the application reaches this state, it will
         * quit right after - refrain from taking any action which could affect the clean shutdown of the
         * application. At this stage, all the resources have been successfully cleaned up and the application
         * is only waiting to be automatically killed.
         */
        ReadyForShutdown = HEMERA_ENUM_Application_ApplicationStatus_ReadyForShutdown,
        /// The @ref Application is in an unkown state.
        Unknown = HEMERA_ENUM_Application_ApplicationStatus_Unknown
    };

    enum class ResourceDomain : quint8 {
        Defaults = HEMERA_ENUM_Application_ResourceDomain_Defaults,
        Application = HEMERA_ENUM_Application_ResourceDomain_Application,
        Orbit = HEMERA_ENUM_Application_ResourceDomain_Orbit
    };
    Q_ENUM(ResourceDomain)

    /**
     * @brief Default destructor
     *
     * Application should never be deleted explicitly, and never be deleted without being in
     * @ref ReadyForShutdownStatus. Should the destructor be called, it will block the event
     * loop until @ref quit has run and @ref ReadyForShutdownStatus has been reached.
     *
     * @see quit
     */
    virtual ~Application();

    /**
     * @brief Returns the @ref Application global instance.
     *
     * This method can be seen as an equivalent of QCoreApplication::instance(). Only a single instance of
     * @ref Application can be created, and this method returns a pointer to it.
     *
     * @returns The global instance of @ref Application
     */
    static Application *instance();

    /**
     * @brief Returns the current application status
     *
     * @returns The current status of this @ref Application
     */
    ApplicationStatus applicationStatus() const;

    /**
     * @returns The @ref Application's id
     */
    static QString id();

    static bool isSatellite();

    /**
     * @returns the path to this application's resource directory.
     *
     * @note It does not include a trailing slash
     */
    Q_INVOKABLE static QString resourcePath(const QString &path, ResourceDomain domain = ResourceDomain::Orbit, bool checkPathExistence = true);

    static qint64 writeToResource(const QString &path, QIODevice *data, ResourceDomain domain = ResourceDomain::Orbit);
    static qint64 writeToResource(const QString &path, const QByteArray &data, ResourceDomain domain = ResourceDomain::Orbit);
    static qint64 writeToResource(const QString &path, const char *data, qint64 size, ResourceDomain domain = ResourceDomain::Orbit);

    /**
     * @brief Sets a configurable variable for static resource paths.
     *
     * When developing an application, it might be possible that, depending on the user or
     * device configuration, you might want to pull resources from different subpaths.
     *
     * Resource variables allow you to do that by setting $variable in the URL path, which
     * will be substituted at resolution time. This means that in case you have a
     * resource:///$MYPREFIX/image.png, calling Application::setResourceVariable("MYPREFIX", "images")
     * will result in resource being resolved to resource:///images/image.png.
     *
     * @note It is advised that setResourceVariable is called in the Application's init phase
     *       especially if you are using Resource from within QML, otherwise the URL resolution
     *       will happen before variable substitution.
     *
     * @param variable The variable name to be substituted. It should NOT contain the trailing '$'.
     * @param value The value to be substituted.
     */
    static void setResourceVariable(const QString &variable, const QString &value);

    /**
     * @brief Executes the application and starts the event loop.
     *
     * This method can be seen as an equivalent of QCoreApplication::exec(), and in fact should replace that
     * very call in your application. It takes care not only of running the event loop, but also to initialize
     * at the right time the rest of your application.
     *
     * After calling exec, you should wait for the application status to transition to @ref StoppedStatus
     * (or wait until the underlying @ref AsyncInitObject becomes ready) for it to be available. At that point,
     * the application state machine will be exposed to Gravity.
     *
     * @note This method should never be called directly - you should use @ref HEMERA_APPLICATION_MAIN macro instead.
     *
     * @returns The exit code of the application.
     */
    int exec();

public Q_SLOTS:
    /**
     * @brief Triggers a safe start of the application.
     *
     * This method triggers a safe start of the application, ensuring it is ready to start up and rejecting
     * the call otherwise. The hard requirement is for the application to be initialized and stopped - that
     * is, the application should be in StoppedStatus.
     *
     * Once in StoppedStatus, it transitions to StartingStatus to allow the application to perform
     * the startup procedure asynchronously. When the applicaton is ready, the status transitions to
     * RunningStatus, and should be ready to process requests. GUI applications should show their main
     * interface when this status is reached.
     *
     * @note This method can be called only from Gravity - any other caller will be rejected,
     *       including direct callers. Developers subclassing @ref Application should reimplement
     *       @ref startImpl instead, allowing them to define their own startup procedure safely.
     *
     * @see startImpl
     */
    void start();
    /**
     * @brief Triggers a safe stop of the application.
     *
     * This method triggers a safe stop of the application, ensuring it is ready to stop and rejecting
     * the call otherwise. The hard requirement is for the application to be initialized and running - that
     * is, the application should be in RunningStatus.
     *
     * Once in RunningStatus, it transitions to StoppingStatus to allow the application to perform
     * the stop procedure asynchronously. When the applicaton is ready, the status transitions to
     * StoppedStatus, and should be ready to process requests. GUI applications should hide their main
     * interface when this status is reached.
     *
     * @returns Whether the request has succeeded or not.
     *
     * @note This method can be called only from Gravity - any other caller will be rejected,
     *       including direct callers. Developers subclassing @ref Application should reimplement
     *       @ref stopImpl instead, allowing them to define their own stopping procedure safely.
     *
     * @see stopImpl
     */
    void stop();

    /**
     * @brief Triggers a safe quit of the application.
     *
     * This method triggers a safe quit of the application, ensuring it has been stopped and unloaded
     * successfully. It heavily affects the state machine - once quit is called, the application is
     * first stopped, if not stopped already.
     *
     * Once in StoppedState, it transitions to ShuttingDownStatus to allow the application to perform
     * a cleanup, if needed. Done that, it finally reaches ReadyForShutdownStatus and the process is
     * automatically killed by the event loop.
     *
     * @returns Whether the request has succeeded or not.
     *
     * @note This method can be called only from Gravity - any other caller will be rejected,
     *       including direct callers. Developers subclassing @ref Application should reimplement
     *       @ref prepareForShutdown instead, allowing them to hook into the shutdown procedure to perform
     *       a last minute cleanup before exit.
     */
    void quit();

    void openURL(const QUrl &url);

    /**
     * @brief Requests an inhibition for orbit switching
     *
     * This method triggers a request to Gravity to prevent switching the active orbit on the current
     * handler until the inhibition is released. Each Application, if allowed, can inhibit only once.
     * While the inhibition is in place, the application won't be shutdown, unless the system is being
     * shutdown as well.
     *
     * You should use inhibition in case your application is performing a critical operation, such
     * as a software update or a long disk write.
     *
     * @p reason The reason for inhibition, to be displayed by Gravity in case any actor requests an Orbit switch.
     *
     * @returns An operation representing the request to Gravity.
     *
     * @sa releaseOrbitSwitchInhibition
     */
    Hemera::Operation *requestOrbitSwitchInhibition(const QString& reason = QString());
    /**
     * @brief Releases a previously set inhibition
     *
     * As a counterpart to requestOrbitSwitchInhibition, this method releases a previously requested
     * and obtained inhibition.
     *
     * @returns An operation representing the request to Gravity.
     *
     * @sa requestOrbitSwitchInhibition
     */
    Hemera::Operation *releaseOrbitSwitchInhibition();

protected:
    explicit Application(ApplicationPrivate &dd, ApplicationProperties *properties);

    /**
     * @brief Defines the result of a state transition.
     *
     * When trying to start, stop or shutdown the @ref Application, some errors can occur. This
     * enum can be fed to setStarted and others to notify whether the operation has failed, and
     * if the failure was critical.
     *
     * Please note that if the failure is critical, the application will transition to @ref FailedStatus
     * and will be shutdown right after. If the fatal error happened during @ref setReadyForShutdown, the
     * application will instead be killed immediately.
     *
     * If the failure is not critical, the application will be rolled back to the previous status instead.
     *
     * @sa setStarted
     * @sa setStopped
     * @sa setReadyForShutdown
     */
    enum class OperationResult : quint8 {
        /// The transition was successful. @ref applicationStatus will transition to the next state.
        Success = HEMERA_ENUM_Application_OperationResult_Success,
        /// The transition was not successful. @ref applicationStatus will rollback to the previous state.
        Failed = HEMERA_ENUM_Application_OperationResult_Failed,
        /** The transition was not successful, and triggered a critical error. @ref applicationStatus will
         *  transition to @ref FailedStatus and will be shutdown right after, or shutdown immediately if
         *  the failure happened while transitioning to @ref ReadyForShutdownStatus.
         */
        Fatal = HEMERA_ENUM_Application_OperationResult_Fatal
    };

    Hemera::Gravity *gravity() const;

protected Q_SLOTS:
    /**
     * @brief Implementation of the start procedure.
     *
     * @ref Application developers must reimplement this method to perform the needed operations to
     * start up the application.
     *
     * From within this method, @ref setStarted should be called once the
     * starting routine has been completed. Failure in doing so will cause the application to wait
     * forever.
     *
     * Once started, the application should show its main interface if it's a @ref GuiApplication, or
     * start its business logic if it's a @ref HeadlessApplication. The application will be considered
     * as Running once @ref setStarted is called.
     *
     * @note It is guaranteed that when this method is called, the application is transitioning from a @ref StoppedStatus
     *
     * @sa setStarted
     * @sa OperationResult
     * @sa ApplicationStatus
     */
    virtual void startImpl() = 0;
    /**
     * @brief Implementation of the stop procedure.
     *
     * @ref Application developers must reimplement this method to perform the needed operations to
     * stop the application.
     *
     * From within this method, @ref setStopped should be called once the
     * stopping routine has been completed. Failure in doing so will cause the application to wait
     * forever.
     *
     * Once stopped, the application should hide its main interface if it's a @ref GuiApplication, or
     * stop its business logic if it's a @ref HeadlessApplication. The application will be considered
     * as stopped or paused once @ref setStarted is called, and it's expected not to react actively to any event.
     *
     * @note It is guaranteed that when this method is called, the application is transitioning from a @ref StartedStatus
     *
     * @sa setStarted
     * @sa OperationResult
     * @sa ApplicationStatus
     */
    virtual void stopImpl() = 0;
    /**
     * @brief Implementation of the shutdown procedure.
     *
     * @ref Application developers can reimplement this method to perform any cleanup before the application
     * quits. It is not compulsory to reimplement this method - its default implementation simply calls
     * setReadyForShutdown, skipping any cleanup phase.
     *
     * From within this method, @ref setStopped should be called once the
     * stopping routine has been completed. Failure in doing so will cause the application to wait
     * forever.
     *
     * Once stopped, the application should hide its main interface if it's a @ref GuiApplication, or
     * stop its business logic if it's a @ref HeadlessApplication. The application will be considered
     * as stopped or paused once @ref setStarted is called, and it's expected not to react actively to any event.
     *
     * @note It is guaranteed that when this method is called, the application is transitioning from a @ref StoppedStatus
     *
     * @sa setStarted
     * @sa OperationResult
     * @sa ApplicationStatus
     */
    virtual void prepareForShutdown();

    virtual Hemera::Operation *openURLImpl(const QUrl &url);

    /**
     * @brief Marks a start operation as finished and completes the transition.
     *
     * setStarted can be called only from a subclass of @ref Application and in the context of a @ref startImpl
     * call. Hence, the @ref Application must be in @ref StartingStatus for this method to take any effect.
     *
     * setStarted can also be used to notify a failure in the starting procedure. See @ref OperationResult for
     * further details.
     *
     * @p result The result of the transition. Defaults to @ref SuccessOperationResult.
     * @p errorName If the result of the transition was not @ref SuccessOperationResult, carries the name of the
     *              error occurred.
     * @p errorMessage If the result of the transition was not @ref SuccessOperationResult, carries the message of the
     *                 error occurred, if any.
     *
     * @sa Hemera::Literals::Errors
     * @sa startImpl
     * @sa OperationResult
     */
    void setStarted(OperationResult result = OperationResult::Success,
                    const QString &errorName = QString(), const QString &errorMessage = QString());
    /**
     * @brief Marks a stop operation as finished and completes the transition.
     *
     * setStopped can be called only from a subclass of @ref Application and in the context of a @ref stopImpl
     * call. Hence, the @ref Application must be in @ref StoppingStatus for this method to take any effect.
     *
     * setStopped can also be used to notify a failure in the stop procedure. See @ref OperationResult for
     * further details.
     *
     * @p result The result of the transition. Defaults to @ref SuccessOperationResult.
     * @p errorName If the result of the transition was not @ref SuccessOperationResult, carries the name of the
     *              error occurred.
     * @p errorMessage If the result of the transition was not @ref SuccessOperationResult, carries the message of the
     *                 error occurred, if any.
     *
     * @sa Hemera::Literals::Errors
     * @sa stopImpl
     * @sa OperationResult
     */
    void setStopped(OperationResult result = OperationResult::Success,
                    const QString &errorName = QString(), const QString &errorMessage = QString());
    /**
     * @brief Marks a prepareForShutdown operation as finished and completes the transition.
     *
     * setReadyForShutdown can be called only from a subclass of @ref Application and in the context of a @ref prepareForShutdown
     * call. Hence, the @ref Application must be in @ref ShuttingDownStatus for this method to take any effect.
     *
     * setReadyForShutdown can also be used to notify a failure in the shutdown procedure. See @ref OperationResult for
     * further details. Please note that, in the specific case of this method, passing @ref FatalOperationResult will
     * cause the application to abort and quit immediately.
     *
     * @p result The result of the transition. Defaults to @ref SuccessOperationResult.
     * @p errorName If the result of the transition was not @ref SuccessOperationResult, carries the name of the
     *              error occurred.
     * @p errorMessage If the result of the transition was not @ref SuccessOperationResult, carries the message of the
     *                 error occurred, if any.
     *
     * @sa Hemera::Literals::Errors
     * @sa prepareForShutdown
     * @sa OperationResult
     */
    void setReadyForShutdown(OperationResult result = OperationResult::Success,
                    const QString &errorName = QString(), const QString &errorMessage = QString());

Q_SIGNALS:
    /**
     * @brief Emitted when the application's status changes.
     *
     * Whenever @ref applicationStatus changes, this status is emitted. Useful for keeping track of
     * the state machine changes, even though from the developer perspective, the machine should be
     * handled from a reimpl perspective.
     *
     * @param status The new status the Application has transitioned to.
     */
    void applicationStatusChanged(Hemera::Application::ApplicationStatus status);
};

}

Q_DECLARE_METATYPE(Hemera::Application::ApplicationStatus)

#endif // HEMERA_HEMERAAPPLICATION_H
